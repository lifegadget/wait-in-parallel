{"version":3,"file":"wait-in-parallel.min.js","sources":["../lib/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ParallelError_1 = require(\"./ParallelError\");\nconst timeout_1 = require(\"./timeout\");\nfunction isDelayedPromise(test) {\n    return typeof test === \"function\" ? true : false;\n}\nclass Parallel {\n    constructor(options = { throw: true }) {\n        this.options = options;\n        this._tasks = [];\n        this._errors = {};\n        this._results = {};\n        this._successful = [];\n        this._failed = [];\n        this._registrations = {};\n        this._failFast = false;\n        this._failureCallbacks = [];\n        this._successCallbacks = [];\n        if (options.throw === undefined) {\n            options.throw = true;\n        }\n    }\n    static create() {\n        const obj = new Parallel();\n        return obj;\n    }\n    get(prop) {\n        const validGets = new Set([\n            \"failed\",\n            \"successful\",\n            \"errors\",\n            \"results\",\n            \"failFast\",\n            \"registrations\"\n        ]);\n        if (!validGets.has(prop)) {\n            throw new Error(`\"${prop}\" is not a valid property to get.`);\n        }\n        return this[`_${prop}`];\n    }\n    add(name, promise, timeout) {\n        try {\n            this.register(name, promise, { timeout });\n        }\n        catch (e) {\n            if (e.name === \"NameAlreadyExists\") {\n                if (isDelayedPromise(promise)) {\n                    throw e;\n                }\n                else {\n                    const newName = Math.random()\n                        .toString(36)\n                        .substr(2, 10);\n                    console.error(`wait-in-parallel: The promise just added as \"${name}\" is a duplicate name to one already being managed but since the Promise is already executing we will give it a new name of \"${newName}\" and continue to manage it!`);\n                    this.register(newName, promise, { timeout });\n                }\n            }\n        }\n        return this;\n    }\n    notifyOnFailure(fn) {\n        this._failureCallbacks.push(fn);\n        return this;\n    }\n    notifyOnSuccess(fn) {\n        this._successCallbacks.push(fn);\n        return this;\n    }\n    clear() {\n        this._tasks = [];\n        this._errors = {};\n        this._results = {};\n        this._successful = [];\n        this._failed = [];\n        this._registrations = {};\n        this._failureCallbacks = [];\n        this._successCallbacks = [];\n        return this;\n    }\n    failFast(flag) {\n        if (flag !== undefined) {\n            this._failFast = flag;\n        }\n        else {\n            this._failFast = true;\n        }\n        return this;\n    }\n    isDone() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.startDelayedTasks();\n            yield Promise.all(this._tasks);\n            const hadErrors = this._failed.length > 0 ? true : false;\n            if (hadErrors) {\n                throw new ParallelError_1.default(this);\n            }\n            return this._results;\n        });\n    }\n    register(name, promise, options) {\n        const existing = new Set(Object.keys(this._registrations));\n        if (existing.has(name)) {\n            const e = new Error(`There is already a registered item using the name \"${name}\" in your Parallel object. Names must be unique, ignoring new addition.`);\n            e.name = \"NameAlreadyExists\";\n            throw e;\n        }\n        else {\n            this._registrations[name] = options;\n        }\n        if (isDelayedPromise(promise)) {\n            this._registrations[name].deferred = promise;\n        }\n        else {\n            const duration = options.timeout || 0;\n            this._tasks.push(timeout_1.default(promise, duration)\n                .then(result => this.handleSuccess(name, result))\n                .catch((err) => this.handleFailure(name, err)));\n        }\n    }\n    handleSuccess(name, result) {\n        this._successful.push(name);\n        this._results[name] = result;\n    }\n    handleFailure(name, err) {\n        this._failed.push(name);\n        this._errors[name] = err;\n        if (this._failFast) {\n            throw new ParallelError_1.default(this);\n        }\n    }\n    startDelayedTasks() {\n        Object.keys(this._registrations).map(name => {\n            const registration = this._registrations[name];\n            if (registration.deferred) {\n                const duration = registration.timeout || 0;\n                try {\n                    this._tasks.push(timeout_1.default(registration.deferred(), duration)\n                        .then((result) => this.handleSuccess(name, result))\n                        .catch((err) => this.handleFailure(name, err)));\n                }\n                catch (e) {\n                    this.handleFailure(name, e);\n                }\n            }\n        });\n    }\n}\nexports.default = Parallel;\n//# sourceMappingURL=index.js.map"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","next","e","rejected","step","result","done","then","apply","Object","defineProperty","exports","ParallelError_1","require","timeout_1","isDelayedPromise","test","Parallel","options","_tasks","_errors","_results","_successful","_failed","_registrations","_failFast","_failureCallbacks","_successCallbacks","undefined","throw","prop","Set","has","Error","this","name","promise","timeout","register","newName","Math","random","toString","substr","error","fn","push","flag","startDelayedTasks","all","length","default","keys","deferred","duration","_this","handleSuccess","catch","err","handleFailure","map","registration","_this2"],"mappings":"6TACA,IAAIA,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,UACnE,IAAKD,IAAMA,EAAIE,UAAU,SAAUC,EAASC,YACtCC,EAAUC,SAAoBL,EAAUM,KAAKD,IAAW,MAAOE,KAAYA,aAC3EC,EAASH,SAAoBL,EAAA,MAAmBK,IAAW,MAAOE,KAAYA,aAC9EE,EAAKC,KAAiBC,KAAOT,EAAQQ,EAAOL,OAAS,IAAIN,EAAE,SAAUG,KAAmBQ,EAAOL,SAAWO,KAAKR,EAAWI,MAC7HR,EAAYA,EAAUa,MAAMhB,EAASC,QAAmBQ,WAGtEQ,OAAOC,eAAeC,QAAS,qBAAuB,IACtD,IAAMC,EAAkBC,QAAQ,mBAC1BC,EAAYD,QAAQ,aAC1B,SAASE,EAAiBC,SACC,mBAATA,MAEZC,8BACUC,iEAAmB,8GACtBA,QAAUA,OACVC,eACAC,gBACAC,iBACAC,oBACAC,gBACAC,uBACAC,WAAY,OACZC,0BACAC,0BACiBC,IAAlBV,EAAQW,UACAA,OAAQ,iEAIR,IAAIZ,mCAGhBa,OACkB,IAAIC,KAClB,SACA,aACA,SACA,UACA,WACA,kBAEWC,IAAIF,SACT,IAAIG,iBAAUH,+CAEjBI,gBAASJ,gCAEhBK,EAAMC,EAASC,YAENC,SAASH,EAAMC,eAExB,MAAOlC,MACY,sBAAXA,EAAEiC,KAA8B,IAC5BpB,EAAiBqB,SACXlC,MAGAqC,EAAUC,KAAKC,SAChBC,SAAS,IACTC,OAAO,EAAG,YACPC,6DAAsDT,0IAAoII,wCAC7LD,SAASC,EAASH,uBAI5BF,6CAEKW,eACPnB,kBAAkBoB,KAAKD,GACrBX,6CAEKW,eACPlB,kBAAkBmB,KAAKD,GACrBX,iDAGFf,eACAC,gBACAC,iBACAC,oBACAC,gBACAC,uBACAE,0BACAC,qBACEO,sCAEFa,eAEItB,eADIG,IAATmB,GACiBA,EAKdb,6CAGA3C,EAAU2C,UAAM,OAAQ,EAAQ,oBAC9Bc,0BACCpD,QAAQqD,IAAIf,KAAKf,QACLe,KAAKX,QAAQ2B,OAAS,QAE9B,IAAItC,EAAgBuC,QAAQjB,aAE/BA,KAAKb,4CAGXc,EAAMC,EAASlB,iBACH,IAAIa,IAAItB,OAAO2C,KAAKlB,KAAKV,iBAC7BQ,IAAIG,GAAO,KACdjC,EAAI,IAAI+B,mEAA4DE,sFACxEA,KAAO,oBACHjC,UAGDsB,eAAeW,GAAQjB,EAE5BH,EAAiBqB,QACZZ,eAAeW,GAAMkB,SAAWjB,MAEpC,KACKkB,EAAWpC,EAAQmB,SAAW,OAC/BlB,OAAO2B,KAAKhC,EAAUqC,QAAQf,EAASkB,GACvC/C,KAAK,mBAAUgD,EAAKC,cAAcrB,EAAM9B,KACxCoD,MAAM,SAACC,UAAQH,EAAKI,cAAcxB,EAAMuB,6CAGvCvB,EAAM9B,QACXiB,YAAYwB,KAAKX,QACjBd,SAASc,GAAQ9B,wCAEZ8B,EAAMuB,WACXnC,QAAQuB,KAAKX,QACbf,QAAQe,GAAQuB,EACjBxB,KAAKT,gBACC,IAAIb,EAAgBuC,QAAQjB,oEAI/BkB,KAAKlB,KAAKV,gBAAgBoC,IAAI,gBAC3BC,EAAeC,EAAKtC,eAAeW,MACrC0B,EAAaR,SAAU,KACjBC,EAAWO,EAAaxB,SAAW,QAEhClB,OAAO2B,KAAKhC,EAAUqC,QAAQU,EAAaR,WAAYC,GACvD/C,KAAK,SAACF,UAAWyD,EAAKN,cAAcrB,EAAM9B,KAC1CoD,MAAM,SAACC,UAAQI,EAAKH,cAAcxB,EAAMuB,MAEjD,MAAOxD,KACEyD,cAAcxB,EAAMjC,4CAM7CS,QAAQwC,QAAUlC"}