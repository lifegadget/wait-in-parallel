{"version":3,"file":"wait-in-parallel.min.js","sources":["../lib/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_types_1 = require(\"common-types\");\nconst ParallelError_1 = require(\"./ParallelError\");\nconst TimeoutError_1 = require(\"./TimeoutError\");\nvar ParallelError_2 = require(\"./ParallelError\");\nexports.ParallelError = ParallelError_2.ParallelError;\nfunction isDelayedPromise(test) {\n    return typeof test === \"function\" ? true : false;\n}\nfunction ensureObject(something) {\n    return typeof something === \"object\" ? something : { value: something };\n}\nclass Parallel {\n    constructor(options = { throw: true }) {\n        this.options = options;\n        this._tasks = [];\n        this._errors = {};\n        this._results = {};\n        this._successful = [];\n        this._failed = [];\n        this._registrations = {};\n        this._failFast = false;\n        this._failureCallbacks = [];\n        this._successCallbacks = [];\n        if (options.throw === undefined) {\n            options.throw = true;\n        }\n    }\n    static create() {\n        const obj = new Parallel();\n        return obj;\n    }\n    _get(prop) {\n        const validGets = new Set([\n            \"failed\",\n            \"successful\",\n            \"errors\",\n            \"results\",\n            \"failFast\",\n            \"registrations\",\n            \"notifyOnFailure\",\n            \"notifyOnSuccess\"\n        ]);\n        if (!validGets.has(prop)) {\n            throw new Error(`\"${prop}\" is not a valid property to get.`);\n        }\n        return this[`_${prop}`];\n    }\n    add(name, promise, timeout) {\n        try {\n            this.register(name, promise, { timeout });\n        }\n        catch (e) {\n            if (e.name === \"NameAlreadyExists\") {\n                if (isDelayedPromise(promise)) {\n                    throw e;\n                }\n                else {\n                    const newName = Math.random()\n                        .toString(36)\n                        .substr(2, 10);\n                    console.error(`wait-in-parallel: The promise just added as \"${name}\" is a duplicate name to one already being managed but since the Promise is already executing we will give it a new name of \"${newName}\" and continue to manage it!`);\n                    this.register(newName, promise, { timeout });\n                }\n            }\n        }\n        return this;\n    }\n    clear() {\n        this._tasks = [];\n        this._errors = {};\n        this._results = {};\n        this._successful = [];\n        this._failed = [];\n        this._registrations = {};\n        this._failureCallbacks = [];\n        this._successCallbacks = [];\n        return this;\n    }\n    failFast(flag) {\n        if (flag !== undefined) {\n            this._failFast = flag;\n        }\n        else {\n            this._failFast = true;\n        }\n        return this;\n    }\n    isDone() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.startDelayedTasks();\n            yield Promise.all(this._tasks);\n            const hadErrors = this._failed.length > 0 ? true : false;\n            if (hadErrors) {\n                throw new ParallelError_1.ParallelError(this);\n            }\n            return this._results;\n        });\n    }\n    isDoneAsArray(includeTaskIdAs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const hash = yield this.isDone();\n            const results = [];\n            Object.keys(hash).map(key => {\n                const keyValue = hash[key];\n                results.push(includeTaskIdAs\n                    ? Object.assign({}, ensureObject(keyValue), { [includeTaskIdAs]: key }) : keyValue);\n            });\n            return results;\n        });\n    }\n    notifyOnFailure(fn) {\n        this._failureCallbacks.push(fn);\n        return this;\n    }\n    notifyOnSuccess(fn) {\n        this._successCallbacks.push(fn);\n        return this;\n    }\n    register(name, promise, options) {\n        const existing = new Set(Object.keys(this._registrations));\n        if (existing.has(name)) {\n            const e = new Error(`There is already a registered item using the name \"${name}\" in your Parallel object. Names must be unique, ignoring new addition.`);\n            e.name = \"NameAlreadyExists\";\n            throw e;\n        }\n        else {\n            this._registrations[name] = options;\n        }\n        if (isDelayedPromise(promise)) {\n            this._registrations[name].deferred = promise;\n        }\n        else {\n            const duration = options.timeout || 0;\n            this._tasks.push(this.promiseOnATimer(promise, name));\n        }\n    }\n    _handleSuccess(name, result) {\n        this._successful.push(name);\n        this._results[name] = result;\n    }\n    _handleFailure(name, err) {\n        this._failed.push(name);\n        this._errors[name] = Object.assign({}, err, { message: err.message, name: err.name, stack: err.stack });\n        if (this._failFast) {\n            throw new ParallelError_1.ParallelError(this);\n        }\n    }\n    startDelayedTasks() {\n        Object.keys(this._registrations).map(name => {\n            const registration = this._registrations[name];\n            const handleSuccess = (result) => this._handleSuccess(name, result);\n            const handleFailure = (err) => this._handleFailure(name, err);\n            const timeout = (d) => __awaiter(this, void 0, void 0, function* () {\n                yield common_types_1.wait(d);\n                throw new TimeoutError_1.default(registration.deferred, d);\n            });\n            if (registration.deferred) {\n                try {\n                    let p = () => registration.deferred();\n                    this._tasks.push(this.promiseOnATimer(registration.deferred(), name));\n                }\n                catch (e) {\n                    this._handleFailure(name, e);\n                }\n            }\n        });\n    }\n    promiseOnATimer(p, name) {\n        const registration = this._registrations[name];\n        const handleSuccess = (result) => this._handleSuccess(name, result);\n        const handleFailure = (err) => this._handleFailure(name, err);\n        const timeout = (d) => __awaiter(this, void 0, void 0, function* () {\n            yield common_types_1.wait(d);\n            throw new TimeoutError_1.default(registration.deferred, d);\n        });\n        const duration = registration.timeout || 0;\n        let timedPromise;\n        try {\n            if (duration > 0) {\n                timedPromise = Promise.race([p, timeout(duration)])\n                    .then(handleSuccess)\n                    .catch(handleFailure);\n            }\n            else {\n                timedPromise = p.then(handleSuccess).catch(handleFailure);\n            }\n            this._tasks.push(timedPromise);\n            return timedPromise;\n        }\n        catch (e) {\n            this._handleFailure(name, e);\n        }\n    }\n}\nexports.default = Parallel;\n//# sourceMappingURL=index.js.map"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","next","e","rejected","step","result","done","then","apply","Object","defineProperty","exports","common_types_1","require","ParallelError_1","TimeoutError_1","ParallelError_2","isDelayedPromise","test","ParallelError","Parallel","options","_tasks","_errors","_results","_successful","_failed","_registrations","_failFast","_failureCallbacks","_successCallbacks","undefined","throw","prop","Set","has","Error","this","name","promise","timeout","register","newName","Math","random","toString","substr","error","flag","startDelayedTasks","all","length","includeTaskIdAs","hash","isDone","results","keys","map","something","keyValue","key","push","assign","_typeof","fn","deferred","promiseOnATimer","err","message","stack","registration","_this","_handleFailure","p","timedPromise","d","handleSuccess","_this2","_handleSuccess","handleFailure","duration","race","wait","default","catch"],"mappings":"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"}